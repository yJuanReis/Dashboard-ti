Checklist: Comportamento e Implementação da Sidebar Mobile (modo retrato e paisagem)

Objetivo
- Definir comportamento responsivo da sidebar em mobile, considerando que algumas páginas precisarão de uso em horizontal (paisagem).
- Em modo paisagem: em certas páginas a sidebar desaparece deixando apenas uma seta/ícone para voltar ao Home.
- Em outras páginas, a sidebar continua responsiva (colapsável, acessível e usável em horizontal).

1) Planejamento de páginas e exceções
- Listar todas as rotas/páginas do app.
- Marcar páginas que exigem ocultação completa da sidebar em landscape (ex: visualização de NVRs, dashboards full-screen, players de vídeo).
- Marcar páginas que precisam da sidebar responsiva mesmo em landscape (ex: páginas com muitos controles, menus avançados).
- Criar um mapa de comportamento por rota (ex: "/nvr" -> hide-on-landscape, "/controle" -> responsive).

2) Estrutura HTML / Componentização
- Criar componente Sidebar separado com props:
  - collapsed (bool)
  - mode ("auto" | "force-hide" | "responsive")
  - showBackArrowOnHide (bool)
  - exceptions (array de rotas)
- Criar componente BackArrow (ícone) acionando navegação para Home.
- Criar wrapper de layout que contém Sidebar + MainContent e passa props conforme a rota.

3) Detectar dispositivo e orientação
- Usar CSS media queries: @media (orientation: landscape) e @media (max-width: 768px).
- Escutar evento JS para mudança de orientação:
  - window.matchMedia("(orientation: landscape)").addEventListener("change", handler)
  - ou window.addEventListener("orientationchange", handler) (fallback)
- Ter função utilitária isMobile() baseada em user-agent e largura (ex: window.innerWidth <= 768).

4) Estado da sidebar e comportamento por rota
- Ter estado centralizado (Context/Store) ou via Provider:
  - sidebarCollapsed (bool)
  - sidebarMode (enum)
  - lastInteractionTimestamp (timestamp)
- Ao navegar para uma página:
  - Checar o mapa de comportamento: definir sidebarMode para "force-hide" ou "responsive".
  - Se mobile + landscape + mode == "force-hide" → collapse sidebar e mostrar apenas BackArrow.
  - Se mobile + portrait → collapse por padrão, mas permitir abrir com botão (hamburger).
  - Se user explicitamente abriu a sidebar (toggle), salvar preferência temporária (sessionStorage) para evitar comportamento intrusivo.

5) Animação e UX visual
- Usar transições suaves (transform: translateX) para ocultar/mostrar.
- Quando a sidebar estiver oculta no landscape, mostrar um pequeno tab/handle com seta para voltar ao Home (ou abrir sidebar ao tocar, dependendo da página).
- Garantir que o MainContent ocupe 100% da largura quando a sidebar estiver oculta.
- Adicionar overlay escuro sem bloquear totalmente (opcional) quando sidebar aberta no modo portrait.

6) Acessibilidade (a11y)
- Quando sidebar abrir, mover foco para o primeiro item da sidebar e habilitar trap de foco.
- Fornecer teclas de atalho (Esc para fechar).
- Usar aria-expanded, aria-hidden corretamente.
- Ícones com aria-label (ex: "Voltar ao início", "Abrir menu").

7) Interações por toque / Gestos
- Implementar swipe-to-open / swipe-to-close:
  - swipe right a partir da borda esquerda = abrir (somente em portrait ou em páginas onde aplicável).
  - swipe left para fechar.
- Detectar conflitos com gestos do sistema (cautela no iOS).
- Fornecer fallback de botão se gestos não estiverem disponíveis.

8) Comportamento ao girar a tela (orientation change)
- Salvar estado anterior (aberta/fechada) ao girar.
- Ao girar para landscape:
  - Se página marcada como "hide-on-landscape": fechar sidebar e exibir BackArrow.
  - Se página marcada como "responsive": manter ou ajustar para collapsed mas disponível.
- Ao girar para portrait:
  - Restaurar comportamento padrão do mobile (collapsed por padrão, exceto se usuário abriu explicitamente).

9) Navegação e botão de voltar (BackArrow)
- Se sidebar estiver oculta, exibir BackArrow fixo no canto superior esquerdo (ou conforme UI) com ação: navigate("/") ou comportamento configurável.
- O BackArrow deve ter tamanho e alvo de toque adequados (>=44px).
- Fornecer opção de long-press para abrir menu rápido (opcional).

10) Performance e carga
- Lazy-load do conteúdo da sidebar (menus pesados, avatares, listas) — carregar apenas quando o usuário abrir.
- Evitar reflows pesados ao abrir/fechar — usar transform e will-change.
- Evitar listeners duplicados de orientationchange em múltiplos componentes — centralizar no layout.

11) Testes
- Testar em vários tamanhos de tela (devtools e dispositivos reais):
  - Portrait mobile (ex: 360x800)
  - Landscape mobile (ex: 800x360)
  - iOS Safari, Android Chrome
- Testar rotas que exigem hide-on-landscape e responsive.
- Testar gestos, backarrow, foco, teclado, leitores de tela.
- Testar com e sem preferência salva em sessionStorage/localStorage.
- Testar limitações de iOS (gestos do sistema) e ajustar margem de ativação.

12) Logging e métricas (opcional)
- Logar eventos de abertura/fechamento (para análise de uso).
- Medir taxa de abertura em landscape para reavaliar UX.

13) Rollout e fallback
- Implementar feature flag para ativar gradualmente.
- Fornecer toggle no settings para "comportamento compactado em landscape" para usuários avançados.
- Fallback simples: se detecção falhar, usar comportamento conservador (mantém sidebar disponível via botão).

14) Código de exemplo rápido (conceito)
- CSS:
  @media (max-width: 768px) {
    .page-header { display: none; } /* Remover título/subtítulo no mobile */
    .sidebar { position: fixed; left: 0; top: 0; height: 100%; transform: translateX(-100%); transition: transform 200ms ease; }
    .sidebar.open { transform: translateX(0); }
    .main.fullwidth { margin-left: 0; }
  }
  @media (orientation: landscape) and (max-width: 1024px) {
    .hide-on-landscape .sidebar { display: none; } /* se quiser ocultar totalmente */
  }

- JS (pseudo):
  const isLandscape = () => window.matchMedia("(orientation: landscape)").matches;
  function onRouteChange(route) {
    const mode = routeMap[route] || "responsive";
    if (isMobile() && isLandscape() && mode === "force-hide") {
      setSidebarCollapsed(true);
      setShowBackArrow(true);
    } else {
      setShowBackArrow(false);
      // manter comportamento padrão ou restaurar estado salvo
    }
  }


