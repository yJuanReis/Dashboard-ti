# üéØ Guia de Pentest Manual

Este guia cont√©m scripts e t√©cnicas para simular ataques e testar a seguran√ßa do sistema manualmente.

## ‚ö†Ô∏è AVISO LEGAL

**Use apenas em sistemas que voc√™ possui ou tem autoriza√ß√£o expl√≠cita para testar!**
Testar seguran√ßa em sistemas sem autoriza√ß√£o √© ilegal.

## üîß Como Usar

1. Abra o DevTools (F12)
2. V√° para a aba Console
3. Cole e execute os scripts abaixo
4. Analise os resultados

## üß™ Testes de Autentica√ß√£o

### Teste 1: Brute Force Attack

```javascript
// Simula m√∫ltiplas tentativas de login
async function testBruteForce() {
  const emails = ['admin@test.com', 'user@test.com', 'test@test.com'];
  const passwords = ['123456', 'password', 'admin', '12345'];
  
  console.log('üîì Testando brute force...');
  
  for (const email of emails) {
    for (const password of passwords) {
      try {
        const { error } = await supabase.auth.signInWithPassword({ email, password });
        if (!error) {
          console.log(`‚úÖ Login bem-sucedido: ${email} / ${password}`);
        } else {
          console.log(`‚ùå Falhou: ${email} / ${password} - ${error.message}`);
        }
        // Pequeno delay para n√£o sobrecarregar
        await new Promise(resolve => setTimeout(resolve, 100));
      } catch (err) {
        console.error('Erro:', err);
      }
    }
  }
  
  console.log('‚úÖ Teste de brute force conclu√≠do');
}

// Execute: testBruteForce()
```

### Teste 2: Token JWT Manipulation

```javascript
// Tenta manipular o token JWT
async function testJWTManipulation() {
  const { data: { session } } = await supabase.auth.getSession();
  
  if (!session) {
    console.log('‚ùå Nenhuma sess√£o ativa');
    return;
  }
  
  console.log('üîë Token atual:', session.access_token.substring(0, 50) + '...');
  
  // Decodifica o token (sem verificar assinatura)
  const parts = session.access_token.split('.');
  const payload = JSON.parse(atob(parts[1]));
  
  console.log('üìã Payload do token:', payload);
  
  // Tenta modificar o payload
  payload.user_id = 'hacked-user-id';
  payload.email = 'hacker@evil.com';
  
  // Reconstr√≥i o token (mas sem a assinatura correta, n√£o funcionar√°)
  const modifiedToken = parts[0] + '.' + btoa(JSON.stringify(payload)) + '.' + parts[2];
  
  console.log('‚ö†Ô∏è Token modificado (mas inv√°lido):', modifiedToken.substring(0, 50) + '...');
  console.log('‚úÖ O Supabase deve rejeitar este token');
}

// Execute: testJWTManipulation()
```

## üé≠ Testes de XSS (Cross-Site Scripting)

### Teste 3: XSS em Inputs

```javascript
// Testa se inputs s√£o vulner√°veis a XSS
function testXSSInputs() {
  const inputs = document.querySelectorAll('input, textarea');
  const xssPayloads = [
    '<script>alert("XSS")</script>',
    '<img src=x onerror=alert("XSS")>',
    '<svg onload=alert("XSS")>',
    'javascript:alert("XSS")',
    '<iframe src="javascript:alert(\'XSS\')"></iframe>',
  ];
  
  console.log('üé≠ Testando XSS em inputs...');
  
  inputs.forEach((input, index) => {
    if (input.type === 'password') return; // Pula senhas
    
    xssPayloads.forEach(payload => {
      input.value = payload;
      console.log(`Input ${index}: ${input.id || input.name} = ${payload}`);
      
      // Verifica se o valor foi sanitizado
      if (input.value === payload) {
        console.warn(`‚ö†Ô∏è Input ${index} aceitou payload XSS: ${payload}`);
      }
    });
  });
  
  console.log('‚úÖ Teste XSS conclu√≠do');
}

// Execute: testXSSInputs()
```

### Teste 4: XSS em URL Parameters

```javascript
// Testa XSS atrav√©s de par√¢metros de URL
function testXSSInURL() {
  const xssPayload = '<script>alert("XSS from URL")</script>';
  const currentUrl = new URL(window.location.href);
  
  // Adiciona payload como par√¢metro
  currentUrl.searchParams.set('test', xssPayload);
  
  console.log('üîó URL com payload XSS:', currentUrl.toString());
  console.log('‚ö†Ô∏è Se o valor aparecer renderizado na p√°gina, h√° vulnerabilidade XSS');
  
  // Tenta acessar a URL
  // window.location.href = currentUrl.toString();
}

// Execute: testXSSInURL()
```

## üíâ Testes de SQL Injection

### Teste 5: SQL Injection (Protegido pelo Supabase)

```javascript
// Tenta SQL injection (deve falhar porque Supabase usa prepared statements)
async function testSQLInjection() {
  const sqlPayloads = [
    "'; DROP TABLE users; --",
    "' OR '1'='1",
    "' UNION SELECT * FROM users --",
    "admin'--",
    "' OR 1=1--",
  ];
  
  console.log('üíâ Testando SQL Injection...');
  console.log('‚ÑπÔ∏è O Supabase usa prepared statements, ent√£o isso deve falhar');
  
  for (const payload of sqlPayloads) {
    try {
      // Tenta usar o payload em uma query
      const { data, error } = await supabase
        .from('passwords') // Substitua pela sua tabela
        .select('*')
        .eq('service', payload)
        .limit(1);
      
      if (error) {
        console.log(`‚úÖ Payload rejeitado: ${payload} - ${error.message}`);
      } else {
        console.warn(`‚ö†Ô∏è Payload pode ter funcionado: ${payload}`);
      }
    } catch (err) {
      console.log(`‚úÖ Erro ao executar payload (esperado): ${payload}`);
    }
  }
  
  console.log('‚úÖ Teste SQL Injection conclu√≠do');
}

// Execute: testSQLInjection()
```

## üîê Testes de Autoriza√ß√£o

### Teste 6: Acesso N√£o Autorizado

```javascript
// Tenta acessar rotas protegidas sem autentica√ß√£o
async function testUnauthorizedAccess() {
  const protectedRoutes = [
    '/home',
    '/senhas',
    '/configuracoes',
    '/controle-nvr',
  ];
  
  console.log('üîê Testando acesso n√£o autorizado...');
  
  // Primeiro, faz logout
  await supabase.auth.signOut();
  
  for (const route of protectedRoutes) {
    try {
      const response = await fetch(window.location.origin + route);
      console.log(`Rota ${route}: Status ${response.status}`);
      
      if (response.status === 200) {
        const text = await response.text();
        if (text.includes('login') || text.includes('Login')) {
          console.log(`‚úÖ ${route} redirecionou para login`);
        } else {
          console.warn(`‚ö†Ô∏è ${route} pode estar acess√≠vel sem autentica√ß√£o`);
        }
      }
    } catch (err) {
      console.log(`‚úÖ ${route} bloqueado ou redirecionado`);
    }
  }
  
  console.log('‚úÖ Teste de autoriza√ß√£o conclu√≠do');
}

// Execute: testUnauthorizedAccess()
```

## üì¶ Testes de Exposi√ß√£o de Dados

### Teste 7: Buscar Secrets no C√≥digo

```javascript
// Procura por secrets expostos no c√≥digo
function findExposedSecrets() {
  console.log('üîç Procurando secrets expostos...');
  
  // Busca no c√≥digo fonte
  const scripts = document.querySelectorAll('script');
  const secrets = [];
  
  scripts.forEach(script => {
    const content = script.textContent || script.innerHTML;
    
    // Padr√µes comuns de secrets
    const patterns = [
      /sk_live_[a-zA-Z0-9]{32,}/g,
      /sk_test_[a-zA-Z0-9]{32,}/g,
      /eyJ[a-zA-Z0-9_-]+\.eyJ[a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+/g, // JWT
      /[a-zA-Z0-9]{32,}/g, // Poss√≠veis API keys
    ];
    
    patterns.forEach(pattern => {
      const matches = content.match(pattern);
      if (matches) {
        secrets.push(...matches);
      }
    });
  });
  
  // Busca no localStorage
  Object.keys(localStorage).forEach(key => {
    const value = localStorage.getItem(key);
    if (value && value.length > 20 && /^[A-Za-z0-9_-]+$/.test(value)) {
      secrets.push(`localStorage.${key}: ${value.substring(0, 20)}...`);
    }
  });
  
  if (secrets.length > 0) {
    console.warn('‚ö†Ô∏è Poss√≠veis secrets encontrados:', secrets);
  } else {
    console.log('‚úÖ Nenhum secret √≥bvio encontrado');
  }
}

// Execute: findExposedSecrets()
```

## üåê Testes de CSRF

### Teste 8: CSRF Attack Simulation

```javascript
// Simula um ataque CSRF
async function testCSRF() {
  console.log('üåê Testando prote√ß√£o CSRF...');
  
  // Tenta fazer uma requisi√ß√£o de outro dom√≠nio
  // (Isso s√≥ funciona se voc√™ tiver outro dom√≠nio configurado)
  
  const maliciousSite = `
    <html>
      <body>
        <form id="csrf-form" action="${window.location.origin}/api/action" method="POST">
          <input type="hidden" name="action" value="delete-all">
        </form>
        <script>
          document.getElementById('csrf-form').submit();
        </script>
      </body>
    </html>
  `;
  
  console.log('üìÑ C√≥digo HTML malicioso:', maliciousSite);
  console.log('‚ÑπÔ∏è O Supabase j√° protege contra CSRF, mas verifique suas pr√≥prias APIs');
}

// Execute: testCSRF()
```

## üöÄ Script Completo de Teste

```javascript
// Executa todos os testes automaticamente
async function runAllPentests() {
  console.log('üöÄ Iniciando pentest completo...\n');
  
  console.log('1Ô∏è‚É£ Teste de Brute Force');
  await testBruteForce();
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  console.log('\n2Ô∏è‚É£ Teste de JWT');
  await testJWTManipulation();
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  console.log('\n3Ô∏è‚É£ Teste de XSS');
  testXSSInputs();
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  console.log('\n4Ô∏è‚É£ Teste de SQL Injection');
  await testSQLInjection();
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  console.log('\n5Ô∏è‚É£ Teste de Autoriza√ß√£o');
  await testUnauthorizedAccess();
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  console.log('\n6Ô∏è‚É£ Busca de Secrets');
  findExposedSecrets();
  
  console.log('\n‚úÖ Pentest completo finalizado!');
  console.log('üìä Revise os resultados acima');
}

// Execute: runAllPentests()
```

## üìä Interpretando Resultados

### ‚úÖ Resultados Esperados (Seguro)

- **Brute Force**: Rate limiting ativa ap√≥s algumas tentativas
- **JWT**: Tokens modificados s√£o rejeitados
- **XSS**: Inputs sanitizam ou escapam dados
- **SQL Injection**: Queries maliciosas s√£o rejeitadas
- **Autoriza√ß√£o**: Rotas protegidas redirecionam para login
- **Secrets**: Nenhum secret encontrado no c√≥digo

### ‚ö†Ô∏è Resultados de Aviso

- Muitas tentativas de login n√£o bloqueadas
- Inputs aceitam scripts sem sanitiza√ß√£o
- Dados sens√≠veis no localStorage
- Headers de seguran√ßa ausentes

### ‚ùå Resultados Cr√≠ticos (Corrigir Imediatamente)

- Login bem-sucedido com credenciais inv√°lidas
- XSS executado com sucesso
- SQL Injection bem-sucedida
- Acesso a rotas protegidas sem autentica√ß√£o
- Secrets expostos no c√≥digo

## üîß Ferramentas Adicionais

### Burp Suite
- Proxy para interceptar requisi√ß√µes
- Scanner autom√°tico de vulnerabilidades
- Fuzzer para testes

### OWASP ZAP
- Scanner de seguran√ßa gratuito
- Testes automatizados
- Relat√≥rios detalhados

### Postman
- Testar APIs manualmente
- Criar collections de testes
- Automatizar requisi√ß√µes

## üìö Recursos

- [OWASP Testing Guide](https://owasp.org/www-project-web-security-testing-guide/)
- [PortSwigger Web Security Academy](https://portswigger.net/web-security)
- [HackerOne](https://www.hackerone.com/)

---

**Lembre-se**: Use essas t√©cnicas apenas para melhorar a seguran√ßa do seu pr√≥prio sistema!


